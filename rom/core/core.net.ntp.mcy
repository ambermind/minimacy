// SPDX-License-Identifier: GPL-3.0-only
// Copyright (c) 2022, Sylvain Huet, Ambermind
// Minimacy (r) System

// this implementation is not using milliseconds so that it works on 32 bits targets
// the resulting time is accurate to one second

const NTP_SERVER="20.101.57.9";;	// time.windows.com
const NTP_PORT=123;;
const DELTA1900=2208988800;;	// seconds from 01/01/1900 to 01/01/1970

fun _strTime(t)=
	strConcat(strInt32Msb(t+DELTA1900), "\0\0\0\0");;
	
fun _strReadTime(data, i)=
	let strRead32Msb(data, i)-DELTA1900 -> seconds in
	seconds;;

fun _ntpReceive(udp, t3, data)=
	udpClose(udp);
	if strLength(data)>=48 then
	// we use bigNumbers to prevent the 'year 2038 problem' on 32 bits targets
		let bigAbs(bigFromInt(_strReadTime(data, 24))) -> t0 in
		let bigAbs(bigFromInt(_strReadTime(data, 32))) -> t1 in
		let bigAbs(bigFromInt(_strReadTime(data, 40))) -> t2 in
		let bigAbs(bigFromInt(t3)) -> t3 in
		let \bigNum (t1+t2)/2 -> tServer in
		let \bigNum (t0+t3)/2 -> tClient in
		let intFromBig(\bigNum tServer-tClient) -> dt in
		time()+dt;;

fun ntpRequest(cb) =
	let udpCreate(NTP_SERVER, NTP_PORT, nil, NTP_PORT) -> udp in
	if udp==nil then (call cb(nil);nil)
	else
	let strBuild([
		strInt32Msb(0xd9000afa),
		strInt32Msb(0),
		strInt32Msb(0x00010290),
		strInt32Msb(0),
		strInt32Msb(0), strInt32Msb(0),
		strInt32Msb(0), strInt32Msb(0),
		strInt32Msb(0), strInt32Msb(0),
		_strTime(time())
	]) -> trame in (
		udpOnEvent(udp, lambda(data)=
			let _ntpReceive(udp, time(), data) -> t in (
				timeSet(t);
				call cb(t)
			)
		, nil);
		udpSend(udp, trame)
	);;
	
//------- demo
fun main()=
	let time() -> t in
	echoLn strFormat("local time: *", fullDate(t));
	ntpRequest((lambda(t)= 
		echoLn t;
		let time() -> t in
		echoLn strFormat("ntp time  : *", fullDate(t));
	));
	echoLn "done";;